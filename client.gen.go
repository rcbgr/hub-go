// Package hub provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package hub

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	UsernamePasswordScopes = "usernamePassword.Scopes"
)

// Defines values for FarcasterNetwork.
const (
	FARCASTERNETWORKDEVNET  FarcasterNetwork = "FARCASTER_NETWORK_DEVNET"
	FARCASTERNETWORKMAINNET FarcasterNetwork = "FARCASTER_NETWORK_MAINNET"
	FARCASTERNETWORKTESTNET FarcasterNetwork = "FARCASTER_NETWORK_TESTNET"
)

// Defines values for HashScheme.
const (
	HASHSCHEMEBLAKE3 HashScheme = "HASH_SCHEME_BLAKE3"
)

// Defines values for IdRegisterEventType.
const (
	IDREGISTEREVENTTYPECHANGERECOVERY IdRegisterEventType = "ID_REGISTER_EVENT_TYPE_CHANGE_RECOVERY"
	IDREGISTEREVENTTYPEREGISTER       IdRegisterEventType = "ID_REGISTER_EVENT_TYPE_REGISTER"
	IDREGISTEREVENTTYPETRANSFER       IdRegisterEventType = "ID_REGISTER_EVENT_TYPE_TRANSFER"
)

// Defines values for LinkType.
const (
	Follow LinkType = "follow"
)

// Defines values for MessageType.
const (
	MESSAGETYPECASTADD                   MessageType = "MESSAGE_TYPE_CAST_ADD"
	MESSAGETYPECASTREMOVE                MessageType = "MESSAGE_TYPE_CAST_REMOVE"
	MESSAGETYPEFRAMEACTION               MessageType = "MESSAGE_TYPE_FRAME_ACTION"
	MESSAGETYPELINKADD                   MessageType = "MESSAGE_TYPE_LINK_ADD"
	MESSAGETYPELINKREMOVE                MessageType = "MESSAGE_TYPE_LINK_REMOVE"
	MESSAGETYPEREACTIONADD               MessageType = "MESSAGE_TYPE_REACTION_ADD"
	MESSAGETYPEREACTIONREMOVE            MessageType = "MESSAGE_TYPE_REACTION_REMOVE"
	MESSAGETYPEUSERDATAADD               MessageType = "MESSAGE_TYPE_USER_DATA_ADD"
	MESSAGETYPEUSERNAMEPROOF             MessageType = "MESSAGE_TYPE_USERNAME_PROOF"
	MESSAGETYPEVERIFICATIONADDETHADDRESS MessageType = "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS"
	MESSAGETYPEVERIFICATIONREMOVE        MessageType = "MESSAGE_TYPE_VERIFICATION_REMOVE"
)

// Defines values for OnChainEventType.
const (
	EVENTTYPEIDREGISTER     OnChainEventType = "EVENT_TYPE_ID_REGISTER"
	EVENTTYPESIGNER         OnChainEventType = "EVENT_TYPE_SIGNER"
	EVENTTYPESIGNERMIGRATED OnChainEventType = "EVENT_TYPE_SIGNER_MIGRATED"
	EVENTTYPESTORAGERENT    OnChainEventType = "EVENT_TYPE_STORAGE_RENT"
)

// Defines values for ReactionType.
const (
	REACTIONTYPELIKE   ReactionType = "REACTION_TYPE_LIKE"
	REACTIONTYPERECAST ReactionType = "REACTION_TYPE_RECAST"
)

// Defines values for SignatureScheme.
const (
	SIGNATURESCHEMEED25519 SignatureScheme = "SIGNATURE_SCHEME_ED25519"
	SIGNATURESCHEMEEIP712  SignatureScheme = "SIGNATURE_SCHEME_EIP712"
)

// Defines values for SignerEventType.
const (
	SIGNEREVENTTYPEADD        SignerEventType = "SIGNER_EVENT_TYPE_ADD"
	SIGNEREVENTTYPEADMINRESET SignerEventType = "SIGNER_EVENT_TYPE_ADMIN_RESET"
	SIGNEREVENTTYPEREMOVE     SignerEventType = "SIGNER_EVENT_TYPE_REMOVE"
)

// Defines values for StoreType.
const (
	STORETYPECASTS          StoreType = "STORE_TYPE_CASTS"
	STORETYPELINKS          StoreType = "STORE_TYPE_LINKS"
	STORETYPEREACTIONS      StoreType = "STORE_TYPE_REACTIONS"
	STORETYPEUSERDATA       StoreType = "STORE_TYPE_USER_DATA"
	STORETYPEUSERNAMEPROOFS StoreType = "STORE_TYPE_USERNAME_PROOFS"
	STORETYPEVERIFICATIONS  StoreType = "STORE_TYPE_VERIFICATIONS"
)

// Defines values for UserDataType.
const (
	USERDATATYPEBIO      UserDataType = "USER_DATA_TYPE_BIO"
	USERDATATYPEDISPLAY  UserDataType = "USER_DATA_TYPE_DISPLAY"
	USERDATATYPEPFP      UserDataType = "USER_DATA_TYPE_PFP"
	USERDATATYPEURL      UserDataType = "USER_DATA_TYPE_URL"
	USERDATATYPEUSERNAME UserDataType = "USER_DATA_TYPE_USERNAME"
)

// Defines values for UserNameType.
const (
	USERNAMETYPEENSL1 UserNameType = "USERNAME_TYPE_ENS_L1"
	USERNAMETYPEFNAME UserNameType = "USERNAME_TYPE_FNAME"
)

// CastAdd defines model for CastAdd.
type CastAdd struct {
	Data struct {
		// CastAddBody Adds a new Cast
		CastAddBody CastAddBody `json:"castAddBody"`
		Fid         uint64      `json:"fid"`

		// Network Farcaster network the message is intended for.
		// - FARCASTER_NETWORK_MAINNET: Public primary network
		//  - FARCASTER_NETWORK_TESTNET: Public test network
		//  - FARCASTER_NETWORK_DEVNET: Private test network
		Network   FarcasterNetwork `json:"network"`
		Timestamp int64            `json:"timestamp"`

		// Type Type of the MessageBody.
		//  - MESSAGE_TYPE_CAST_ADD: Add a new Cast
		//  - MESSAGE_TYPE_CAST_REMOVE: Remove an existing Cast
		//  - MESSAGE_TYPE_REACTION_ADD: Add a Reaction to a Cast
		//  - MESSAGE_TYPE_REACTION_REMOVE: Remove a Reaction from a Cast
		//  - MESSAGE_TYPE_LINK_ADD: Add a new Link
		//  - MESSAGE_TYPE_LINK_REMOVE: Remove an existing Link
		//  - MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS: Add a Verification of an Ethereum Address
		//  - MESSAGE_TYPE_VERIFICATION_REMOVE: Remove a Verification
		//  - MESSAGE_TYPE_USER_DATA_ADD: Add metadata about a user
		//  - MESSAGE_TYPE_USERNAME_PROOF: Add or replace a username proof
		//  - MESSAGE_TYPE_FRAME_ACTION: A Farcaster Frame action
		Type MessageType `json:"type"`
	} `json:"data"`
	Hash string `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// CastAddBody Adds a new Cast
type CastAddBody struct {
	Embeds            []Embed  `json:"embeds"`
	EmbedsDeprecated  []string `json:"embedsDeprecated"`
	Mentions          []uint64 `json:"mentions"`
	MentionsPositions []int64  `json:"mentionsPositions"`

	// ParentCastId Identifier used to look up a Cast
	ParentCastId *CastId `json:"parentCastId,omitempty"`
	ParentUrl    *string `json:"parentUrl,omitempty"`
	Text         string  `json:"text"`
}

// CastEmbed defines model for CastEmbed.
type CastEmbed struct {
	// CastId Identifier used to look up a Cast
	CastId CastId `json:"castId"`
}

// CastHash defines model for CastHash.
type CastHash = string

// CastId Identifier used to look up a Cast
type CastId struct {
	Fid  uint64   `json:"fid"`
	Hash CastHash `json:"hash"`
}

// CastRemove defines model for CastRemove.
type CastRemove struct {
	Data struct {
		// CastRemoveBody Removes an existing Cast
		CastRemoveBody CastRemoveBody `json:"castRemoveBody"`
		Fid            uint64         `json:"fid"`

		// Network Farcaster network the message is intended for.
		// - FARCASTER_NETWORK_MAINNET: Public primary network
		//  - FARCASTER_NETWORK_TESTNET: Public test network
		//  - FARCASTER_NETWORK_DEVNET: Private test network
		Network   FarcasterNetwork `json:"network"`
		Timestamp int64            `json:"timestamp"`

		// Type Type of the MessageBody.
		//  - MESSAGE_TYPE_CAST_ADD: Add a new Cast
		//  - MESSAGE_TYPE_CAST_REMOVE: Remove an existing Cast
		//  - MESSAGE_TYPE_REACTION_ADD: Add a Reaction to a Cast
		//  - MESSAGE_TYPE_REACTION_REMOVE: Remove a Reaction from a Cast
		//  - MESSAGE_TYPE_LINK_ADD: Add a new Link
		//  - MESSAGE_TYPE_LINK_REMOVE: Remove an existing Link
		//  - MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS: Add a Verification of an Ethereum Address
		//  - MESSAGE_TYPE_VERIFICATION_REMOVE: Remove a Verification
		//  - MESSAGE_TYPE_USER_DATA_ADD: Add metadata about a user
		//  - MESSAGE_TYPE_USERNAME_PROOF: Add or replace a username proof
		//  - MESSAGE_TYPE_FRAME_ACTION: A Farcaster Frame action
		Type MessageType `json:"type"`
	} `json:"data"`
	Hash string `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// CastRemoveBody Removes an existing Cast
type CastRemoveBody struct {
	TargetHash []byte `json:"targetHash"`
}

// DbStats defines model for DbStats.
type DbStats struct {
	NumFidEvents   uint64 `json:"numFidEvents"`
	NumFnameEvents uint64 `json:"numFnameEvents"`
	NumMessages    uint64 `json:"numMessages"`
}

// Embed defines model for Embed.
type Embed struct {
	union json.RawMessage
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Code     int    `json:"code"`
	Details  string `json:"details"`
	ErrCode  string `json:"errCode"`
	Metadata struct {
		Errcode []string `json:"errcode"`
	} `json:"metadata"`
	Name        string `json:"name"`
	Presentable bool   `json:"presentable"`
}

// FarcasterNetwork Farcaster network the message is intended for.
// - FARCASTER_NETWORK_MAINNET: Public primary network
//   - FARCASTER_NETWORK_TESTNET: Public test network
//   - FARCASTER_NETWORK_DEVNET: Private test network
type FarcasterNetwork string

// FidsResponse defines model for FidsResponse.
type FidsResponse struct {
	Fids          []uint64 `json:"fids"`
	NextPageToken []byte   `json:"nextPageToken"`
}

// FrameActionBody A Farcaster Frame action
type FrameActionBody struct {
	ButtonIndex int32 `json:"buttonIndex"`

	// CastId Identifier used to look up a Cast
	CastId CastId `json:"castId"`
	Url    string `json:"url"`
}

// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
type HashScheme string

// HubEvent defines model for HubEvent.
type HubEvent struct {
	union json.RawMessage
}

// HubEventMergeMessage defines model for HubEventMergeMessage.
type HubEventMergeMessage struct {
	Id               uint64           `json:"id"`
	MergeMessageBody MergeMessageBody `json:"mergeMessageBody"`
	Type             string           `json:"type"`
}

// HubEventMergeOnChainEvent defines model for HubEventMergeOnChainEvent.
type HubEventMergeOnChainEvent struct {
	Id                    uint64                `json:"id"`
	MergeOnChainEventBody MergeOnChainEventBody `json:"mergeOnChainEventBody"`
	Type                  string                `json:"type"`
}

// HubEventMergeUsernameProof defines model for HubEventMergeUsernameProof.
type HubEventMergeUsernameProof struct {
	Id                     uint64                 `json:"id"`
	MergeUsernameProofBody MergeUserNameProofBody `json:"mergeUsernameProofBody"`
	Type                   string                 `json:"type"`
}

// HubEventPruneMessage defines model for HubEventPruneMessage.
type HubEventPruneMessage struct {
	Id               uint64           `json:"id"`
	PruneMessageBody PruneMessageBody `json:"pruneMessageBody"`
	Type             string           `json:"type"`
}

// HubEventRevokeMessage defines model for HubEventRevokeMessage.
type HubEventRevokeMessage struct {
	Id                uint64            `json:"id"`
	RevokeMessageBody RevokeMessageBody `json:"revokeMessageBody"`
	Type              string            `json:"type"`
}

// HubInfoResponse defines model for HubInfoResponse.
type HubInfoResponse struct {
	DbStats        *DbStats `json:"dbStats,omitempty"`
	HubOperatorFid uint64   `json:"hubOperatorFid"`
	IsSyncing      bool     `json:"isSyncing"`
	Nickname       string   `json:"nickname"`
	PeerId         string   `json:"peerId"`
	RootHash       string   `json:"rootHash"`
	Version        string   `json:"version"`
}

// IdRegisterEventBody defines model for IdRegisterEventBody.
type IdRegisterEventBody struct {
	EventType       IdRegisterEventType `json:"eventType"`
	From            string              `json:"from"`
	RecoveryAddress string              `json:"recoveryAddress"`
	To              string              `json:"to"`
}

// IdRegisterEventType defines model for IdRegisterEventType.
type IdRegisterEventType string

// LinkAdd defines model for LinkAdd.
type LinkAdd struct {
	Data struct {
		Fid uint64 `json:"fid"`

		// LinkBody Adds or removes a Link
		LinkBody LinkBody `json:"linkBody"`

		// Network Farcaster network the message is intended for.
		// - FARCASTER_NETWORK_MAINNET: Public primary network
		//  - FARCASTER_NETWORK_TESTNET: Public test network
		//  - FARCASTER_NETWORK_DEVNET: Private test network
		Network   FarcasterNetwork `json:"network"`
		Timestamp int64            `json:"timestamp"`

		// Type Type of the MessageBody.
		//  - MESSAGE_TYPE_CAST_ADD: Add a new Cast
		//  - MESSAGE_TYPE_CAST_REMOVE: Remove an existing Cast
		//  - MESSAGE_TYPE_REACTION_ADD: Add a Reaction to a Cast
		//  - MESSAGE_TYPE_REACTION_REMOVE: Remove a Reaction from a Cast
		//  - MESSAGE_TYPE_LINK_ADD: Add a new Link
		//  - MESSAGE_TYPE_LINK_REMOVE: Remove an existing Link
		//  - MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS: Add a Verification of an Ethereum Address
		//  - MESSAGE_TYPE_VERIFICATION_REMOVE: Remove a Verification
		//  - MESSAGE_TYPE_USER_DATA_ADD: Add metadata about a user
		//  - MESSAGE_TYPE_USERNAME_PROOF: Add or replace a username proof
		//  - MESSAGE_TYPE_FRAME_ACTION: A Farcaster Frame action
		Type MessageType `json:"type"`
	} `json:"data"`
	Hash string `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// LinkBody Adds or removes a Link
type LinkBody struct {
	DisplayTimestamp *int64 `json:"displayTimestamp,omitempty"`
	TargetFid        uint64 `json:"targetFid"`

	// Type Type of Link.
	// - follow: Follow another user
	Type LinkType `json:"type"`
}

// LinkRemove defines model for LinkRemove.
type LinkRemove struct {
	Data struct {
		Fid uint64 `json:"fid"`

		// LinkBody Adds or removes a Link
		LinkBody LinkBody `json:"linkBody"`

		// Network Farcaster network the message is intended for.
		// - FARCASTER_NETWORK_MAINNET: Public primary network
		//  - FARCASTER_NETWORK_TESTNET: Public test network
		//  - FARCASTER_NETWORK_DEVNET: Private test network
		Network   FarcasterNetwork `json:"network"`
		Timestamp int64            `json:"timestamp"`

		// Type Type of the MessageBody.
		//  - MESSAGE_TYPE_CAST_ADD: Add a new Cast
		//  - MESSAGE_TYPE_CAST_REMOVE: Remove an existing Cast
		//  - MESSAGE_TYPE_REACTION_ADD: Add a Reaction to a Cast
		//  - MESSAGE_TYPE_REACTION_REMOVE: Remove a Reaction from a Cast
		//  - MESSAGE_TYPE_LINK_ADD: Add a new Link
		//  - MESSAGE_TYPE_LINK_REMOVE: Remove an existing Link
		//  - MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS: Add a Verification of an Ethereum Address
		//  - MESSAGE_TYPE_VERIFICATION_REMOVE: Remove a Verification
		//  - MESSAGE_TYPE_USER_DATA_ADD: Add metadata about a user
		//  - MESSAGE_TYPE_USERNAME_PROOF: Add or replace a username proof
		//  - MESSAGE_TYPE_FRAME_ACTION: A Farcaster Frame action
		Type MessageType `json:"type"`
	} `json:"data"`
	Hash string `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// LinkType Type of Link.
// - follow: Follow another user
type LinkType string

// MergeMessageBody defines model for MergeMessageBody.
type MergeMessageBody struct {
	DeletedMessages []Message `json:"deletedMessages"`

	// Message *
	// A Message is a delta operation on the Farcaster network. The message protobuf is an envelope
	// that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
	Message Message `json:"message"`
}

// MergeOnChainEventBody defines model for MergeOnChainEventBody.
type MergeOnChainEventBody struct {
	OnChainEvent OnChainEvent `json:"onChainEvent"`
}

// MergeUserNameProofBody defines model for MergeUserNameProofBody.
type MergeUserNameProofBody struct {
	DeletedUsernameProof *UserNameProof `json:"deletedUsernameProof,omitempty"`

	// DeletedUsernameProofMessage *
	// A Message is a delta operation on the Farcaster network. The message protobuf is an envelope
	// that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
	DeletedUsernameProofMessage *Message       `json:"deletedUsernameProofMessage,omitempty"`
	UsernameProof               *UserNameProof `json:"usernameProof,omitempty"`

	// UsernameProofMessage *
	// A Message is a delta operation on the Farcaster network. The message protobuf is an envelope
	// that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
	UsernameProofMessage *Message `json:"usernameProofMessage,omitempty"`
}

// Message defines model for Message.
type Message struct {
	Data Message_Data `json:"data"`
	Hash string       `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// Message_Data defines model for Message.Data.
type Message_Data struct {
	union json.RawMessage
}

// MessageCommon defines model for MessageCommon.
type MessageCommon struct {
	Hash string `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// MessageDataCastAdd defines model for MessageDataCastAdd.
type MessageDataCastAdd struct {
	// CastAddBody Adds a new Cast
	CastAddBody CastAddBody `json:"castAddBody"`
	Fid         uint64      `json:"fid"`

	// Network Farcaster network the message is intended for.
	// - FARCASTER_NETWORK_MAINNET: Public primary network
	//  - FARCASTER_NETWORK_TESTNET: Public test network
	//  - FARCASTER_NETWORK_DEVNET: Private test network
	Network   FarcasterNetwork `json:"network"`
	Timestamp int64            `json:"timestamp"`
	Type      string           `json:"type"`
}

// MessageDataCastRemove defines model for MessageDataCastRemove.
type MessageDataCastRemove struct {
	// CastRemoveBody Removes an existing Cast
	CastRemoveBody CastRemoveBody `json:"castRemoveBody"`
	Fid            uint64         `json:"fid"`

	// Network Farcaster network the message is intended for.
	// - FARCASTER_NETWORK_MAINNET: Public primary network
	//  - FARCASTER_NETWORK_TESTNET: Public test network
	//  - FARCASTER_NETWORK_DEVNET: Private test network
	Network   FarcasterNetwork `json:"network"`
	Timestamp int64            `json:"timestamp"`
	Type      string           `json:"type"`
}

// MessageDataCommon defines model for MessageDataCommon.
type MessageDataCommon struct {
	Fid uint64 `json:"fid"`

	// Network Farcaster network the message is intended for.
	// - FARCASTER_NETWORK_MAINNET: Public primary network
	//  - FARCASTER_NETWORK_TESTNET: Public test network
	//  - FARCASTER_NETWORK_DEVNET: Private test network
	Network   FarcasterNetwork `json:"network"`
	Timestamp int64            `json:"timestamp"`
	Type      string           `json:"type"`
}

// MessageDataFrameAction defines model for MessageDataFrameAction.
type MessageDataFrameAction struct {
	Fid uint64 `json:"fid"`

	// FrameActionBody A Farcaster Frame action
	FrameActionBody FrameActionBody `json:"frameActionBody"`

	// Network Farcaster network the message is intended for.
	// - FARCASTER_NETWORK_MAINNET: Public primary network
	//  - FARCASTER_NETWORK_TESTNET: Public test network
	//  - FARCASTER_NETWORK_DEVNET: Private test network
	Network   FarcasterNetwork `json:"network"`
	Timestamp int64            `json:"timestamp"`
	Type      string           `json:"type"`
}

// MessageDataLink defines model for MessageDataLink.
type MessageDataLink struct {
	Fid uint64 `json:"fid"`

	// LinkBody Adds or removes a Link
	LinkBody LinkBody `json:"linkBody"`

	// Network Farcaster network the message is intended for.
	// - FARCASTER_NETWORK_MAINNET: Public primary network
	//  - FARCASTER_NETWORK_TESTNET: Public test network
	//  - FARCASTER_NETWORK_DEVNET: Private test network
	Network   FarcasterNetwork `json:"network"`
	Timestamp int64            `json:"timestamp"`
	Type      string           `json:"type"`
}

// MessageDataReaction defines model for MessageDataReaction.
type MessageDataReaction struct {
	Fid uint64 `json:"fid"`

	// Network Farcaster network the message is intended for.
	// - FARCASTER_NETWORK_MAINNET: Public primary network
	//  - FARCASTER_NETWORK_TESTNET: Public test network
	//  - FARCASTER_NETWORK_DEVNET: Private test network
	Network FarcasterNetwork `json:"network"`

	// ReactionBody Adds or removes a Reaction from a Cast
	ReactionBody ReactionBody `json:"reactionBody"`
	Timestamp    int64        `json:"timestamp"`
	Type         string       `json:"type"`
}

// MessageDataUserDataAdd defines model for MessageDataUserDataAdd.
type MessageDataUserDataAdd struct {
	Fid uint64 `json:"fid"`

	// Network Farcaster network the message is intended for.
	// - FARCASTER_NETWORK_MAINNET: Public primary network
	//  - FARCASTER_NETWORK_TESTNET: Public test network
	//  - FARCASTER_NETWORK_DEVNET: Private test network
	Network   FarcasterNetwork `json:"network"`
	Timestamp int64            `json:"timestamp"`
	Type      string           `json:"type"`

	// UserDataBody Adds metadata about a user
	UserDataBody UserDataBody `json:"userDataBody"`
}

// MessageDataUsernameProof defines model for MessageDataUsernameProof.
type MessageDataUsernameProof struct {
	Fid uint64 `json:"fid"`

	// Network Farcaster network the message is intended for.
	// - FARCASTER_NETWORK_MAINNET: Public primary network
	//  - FARCASTER_NETWORK_TESTNET: Public test network
	//  - FARCASTER_NETWORK_DEVNET: Private test network
	Network           FarcasterNetwork `json:"network"`
	Timestamp         int64            `json:"timestamp"`
	Type              string           `json:"type"`
	UsernameProofBody UserNameProof    `json:"usernameProofBody"`
}

// MessageDataVerificationAdd defines model for MessageDataVerificationAdd.
type MessageDataVerificationAdd struct {
	Fid uint64 `json:"fid"`

	// Network Farcaster network the message is intended for.
	// - FARCASTER_NETWORK_MAINNET: Public primary network
	//  - FARCASTER_NETWORK_TESTNET: Public test network
	//  - FARCASTER_NETWORK_DEVNET: Private test network
	Network   FarcasterNetwork `json:"network"`
	Timestamp int64            `json:"timestamp"`
	Type      string           `json:"type"`

	// VerificationAddEthAddressBody Adds a Verification of ownership of an Ethereum Address
	VerificationAddEthAddressBody VerificationAddEthAddressBody `json:"verificationAddEthAddressBody"`
}

// MessageDataVerificationRemove defines model for MessageDataVerificationRemove.
type MessageDataVerificationRemove struct {
	Fid uint64 `json:"fid"`

	// Network Farcaster network the message is intended for.
	// - FARCASTER_NETWORK_MAINNET: Public primary network
	//  - FARCASTER_NETWORK_TESTNET: Public test network
	//  - FARCASTER_NETWORK_DEVNET: Private test network
	Network   FarcasterNetwork `json:"network"`
	Timestamp int64            `json:"timestamp"`
	Type      string           `json:"type"`

	// VerificationRemoveBody Removes a Verification of any type
	VerificationRemoveBody VerificationRemoveBody `json:"verificationRemoveBody"`
}

// MessageType Type of the MessageBody.
//   - MESSAGE_TYPE_CAST_ADD: Add a new Cast
//   - MESSAGE_TYPE_CAST_REMOVE: Remove an existing Cast
//   - MESSAGE_TYPE_REACTION_ADD: Add a Reaction to a Cast
//   - MESSAGE_TYPE_REACTION_REMOVE: Remove a Reaction from a Cast
//   - MESSAGE_TYPE_LINK_ADD: Add a new Link
//   - MESSAGE_TYPE_LINK_REMOVE: Remove an existing Link
//   - MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS: Add a Verification of an Ethereum Address
//   - MESSAGE_TYPE_VERIFICATION_REMOVE: Remove a Verification
//   - MESSAGE_TYPE_USER_DATA_ADD: Add metadata about a user
//   - MESSAGE_TYPE_USERNAME_PROOF: Add or replace a username proof
//   - MESSAGE_TYPE_FRAME_ACTION: A Farcaster Frame action
type MessageType string

// OnChainEvent defines model for OnChainEvent.
type OnChainEvent struct {
	union json.RawMessage
}

// OnChainEventCommon defines model for OnChainEventCommon.
type OnChainEventCommon struct {
	BlockHash       string `json:"blockHash"`
	BlockNumber     int    `json:"blockNumber"`
	BlockTimestamp  int    `json:"blockTimestamp"`
	ChainId         int    `json:"chainId"`
	Fid             int    `json:"fid"`
	LogIndex        int    `json:"logIndex"`
	TransactionHash string `json:"transactionHash"`
	TxIndex         int    `json:"txIndex"`
	Type            string `json:"type"`
}

// OnChainEventIdRegister defines model for OnChainEventIdRegister.
type OnChainEventIdRegister struct {
	BlockHash           string              `json:"blockHash"`
	BlockNumber         int                 `json:"blockNumber"`
	BlockTimestamp      int                 `json:"blockTimestamp"`
	ChainId             int                 `json:"chainId"`
	Fid                 int                 `json:"fid"`
	IdRegisterEventBody IdRegisterEventBody `json:"idRegisterEventBody"`
	LogIndex            int                 `json:"logIndex"`
	TransactionHash     string              `json:"transactionHash"`
	TxIndex             int                 `json:"txIndex"`
	Type                string              `json:"type"`
}

// OnChainEventSigner defines model for OnChainEventSigner.
type OnChainEventSigner struct {
	BlockHash       string          `json:"blockHash"`
	BlockNumber     int             `json:"blockNumber"`
	BlockTimestamp  int             `json:"blockTimestamp"`
	ChainId         int             `json:"chainId"`
	Fid             int             `json:"fid"`
	LogIndex        int             `json:"logIndex"`
	SignerEventBody SignerEventBody `json:"signerEventBody"`
	TransactionHash string          `json:"transactionHash"`
	TxIndex         int             `json:"txIndex"`
	Type            string          `json:"type"`
}

// OnChainEventSignerMigrated defines model for OnChainEventSignerMigrated.
type OnChainEventSignerMigrated struct {
	BlockHash               string                  `json:"blockHash"`
	BlockNumber             int                     `json:"blockNumber"`
	BlockTimestamp          int                     `json:"blockTimestamp"`
	ChainId                 int                     `json:"chainId"`
	Fid                     int                     `json:"fid"`
	LogIndex                int                     `json:"logIndex"`
	SignerMigratedEventBody SignerMigratedEventBody `json:"signerMigratedEventBody"`
	TransactionHash         string                  `json:"transactionHash"`
	TxIndex                 int                     `json:"txIndex"`
	Type                    string                  `json:"type"`
}

// OnChainEventStorageRent defines model for OnChainEventStorageRent.
type OnChainEventStorageRent struct {
	BlockHash            string               `json:"blockHash"`
	BlockNumber          int                  `json:"blockNumber"`
	BlockTimestamp       int                  `json:"blockTimestamp"`
	ChainId              int                  `json:"chainId"`
	Fid                  int                  `json:"fid"`
	LogIndex             int                  `json:"logIndex"`
	StorageRentEventBody StorageRentEventBody `json:"storageRentEventBody"`
	TransactionHash      string               `json:"transactionHash"`
	TxIndex              int                  `json:"txIndex"`
	Type                 string               `json:"type"`
}

// OnChainEventType defines model for OnChainEventType.
type OnChainEventType string

// PruneMessageBody defines model for PruneMessageBody.
type PruneMessageBody struct {
	// Message *
	// A Message is a delta operation on the Farcaster network. The message protobuf is an envelope
	// that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
	Message Message `json:"message"`
}

// Reaction defines model for Reaction.
type Reaction struct {
	Data struct {
		Fid uint64 `json:"fid"`

		// Network Farcaster network the message is intended for.
		// - FARCASTER_NETWORK_MAINNET: Public primary network
		//  - FARCASTER_NETWORK_TESTNET: Public test network
		//  - FARCASTER_NETWORK_DEVNET: Private test network
		Network FarcasterNetwork `json:"network"`

		// ReactionBody Adds or removes a Reaction from a Cast
		ReactionBody ReactionBody `json:"reactionBody"`
		Timestamp    int64        `json:"timestamp"`

		// Type Type of the MessageBody.
		//  - MESSAGE_TYPE_CAST_ADD: Add a new Cast
		//  - MESSAGE_TYPE_CAST_REMOVE: Remove an existing Cast
		//  - MESSAGE_TYPE_REACTION_ADD: Add a Reaction to a Cast
		//  - MESSAGE_TYPE_REACTION_REMOVE: Remove a Reaction from a Cast
		//  - MESSAGE_TYPE_LINK_ADD: Add a new Link
		//  - MESSAGE_TYPE_LINK_REMOVE: Remove an existing Link
		//  - MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS: Add a Verification of an Ethereum Address
		//  - MESSAGE_TYPE_VERIFICATION_REMOVE: Remove a Verification
		//  - MESSAGE_TYPE_USER_DATA_ADD: Add metadata about a user
		//  - MESSAGE_TYPE_USERNAME_PROOF: Add or replace a username proof
		//  - MESSAGE_TYPE_FRAME_ACTION: A Farcaster Frame action
		Type MessageType `json:"type"`
	} `json:"data"`
	Hash string `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// ReactionBody Adds or removes a Reaction from a Cast
type ReactionBody struct {
	// TargetCastId Identifier used to look up a Cast
	TargetCastId *CastId `json:"targetCastId,omitempty"`
	TargetUrl    *string `json:"targetUrl,omitempty"`

	// Type Type of Reaction.
	// - REACTION_TYPE_LIKE: Like the target cast
	//  - REACTION_TYPE_RECAST: Share target cast to the user's audience
	Type ReactionType `json:"type"`
}

// ReactionRemove defines model for ReactionRemove.
type ReactionRemove struct {
	Data MessageDataReaction `json:"data"`
	Hash string              `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// ReactionType Type of Reaction.
// - REACTION_TYPE_LIKE: Like the target cast
//   - REACTION_TYPE_RECAST: Share target cast to the user's audience
type ReactionType string

// RevokeMessageBody defines model for RevokeMessageBody.
type RevokeMessageBody struct {
	// Message *
	// A Message is a delta operation on the Farcaster network. The message protobuf is an envelope
	// that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
	Message Message `json:"message"`
}

// SignatureScheme Type of signature scheme used to sign the Message hash
// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
//   - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
type SignatureScheme string

// SignerEventBody defines model for SignerEventBody.
type SignerEventBody struct {
	EventType    SignerEventType `json:"eventType"`
	Key          string          `json:"key"`
	KeyType      int64           `json:"keyType"`
	Metadata     []byte          `json:"metadata"`
	MetadataType int64           `json:"metadataType"`
}

// SignerEventType defines model for SignerEventType.
type SignerEventType string

// SignerMigratedEventBody defines model for SignerMigratedEventBody.
type SignerMigratedEventBody struct {
	MigratedAt int64 `json:"migratedAt"`
}

// StorageLimit defines model for StorageLimit.
type StorageLimit struct {
	Limit     uint64    `json:"limit"`
	StoreType StoreType `json:"storeType"`
}

// StorageLimitsResponse defines model for StorageLimitsResponse.
type StorageLimitsResponse struct {
	Limits []StorageLimit `json:"limits"`
}

// StorageRentEventBody defines model for StorageRentEventBody.
type StorageRentEventBody struct {
	Expiry int64  `json:"expiry"`
	Payer  []byte `json:"payer"`
	Units  int64  `json:"units"`
}

// StoreType defines model for StoreType.
type StoreType string

// UrlEmbed defines model for UrlEmbed.
type UrlEmbed struct {
	Url string `json:"url"`
}

// UserDataAdd defines model for UserDataAdd.
type UserDataAdd struct {
	Data struct {
		Fid uint64 `json:"fid"`

		// Network Farcaster network the message is intended for.
		// - FARCASTER_NETWORK_MAINNET: Public primary network
		//  - FARCASTER_NETWORK_TESTNET: Public test network
		//  - FARCASTER_NETWORK_DEVNET: Private test network
		Network   FarcasterNetwork `json:"network"`
		Timestamp int64            `json:"timestamp"`

		// Type Type of the MessageBody.
		//  - MESSAGE_TYPE_CAST_ADD: Add a new Cast
		//  - MESSAGE_TYPE_CAST_REMOVE: Remove an existing Cast
		//  - MESSAGE_TYPE_REACTION_ADD: Add a Reaction to a Cast
		//  - MESSAGE_TYPE_REACTION_REMOVE: Remove a Reaction from a Cast
		//  - MESSAGE_TYPE_LINK_ADD: Add a new Link
		//  - MESSAGE_TYPE_LINK_REMOVE: Remove an existing Link
		//  - MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS: Add a Verification of an Ethereum Address
		//  - MESSAGE_TYPE_VERIFICATION_REMOVE: Remove a Verification
		//  - MESSAGE_TYPE_USER_DATA_ADD: Add metadata about a user
		//  - MESSAGE_TYPE_USERNAME_PROOF: Add or replace a username proof
		//  - MESSAGE_TYPE_FRAME_ACTION: A Farcaster Frame action
		Type MessageType `json:"type"`

		// UserDataBody Adds metadata about a user
		UserDataBody UserDataBody `json:"userDataBody"`
	} `json:"data"`
	Hash string `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// UserDataBody Adds metadata about a user
type UserDataBody struct {
	// Type Type of UserData.
	// - USER_DATA_TYPE_PFP: Profile Picture for the user
	//  - USER_DATA_TYPE_DISPLAY: Display Name for the user
	//  - USER_DATA_TYPE_BIO: Bio for the user
	//  - USER_DATA_TYPE_URL: URL of the user
	//  - USER_DATA_TYPE_USERNAME: Preferred Name for the user
	Type  UserDataType `json:"type"`
	Value string       `json:"value"`
}

// UserDataType Type of UserData.
// - USER_DATA_TYPE_PFP: Profile Picture for the user
//   - USER_DATA_TYPE_DISPLAY: Display Name for the user
//   - USER_DATA_TYPE_BIO: Bio for the user
//   - USER_DATA_TYPE_URL: URL of the user
//   - USER_DATA_TYPE_USERNAME: Preferred Name for the user
type UserDataType string

// UserNameProof defines model for UserNameProof.
type UserNameProof struct {
	Fid       uint64       `json:"fid"`
	Name      string       `json:"name"`
	Owner     string       `json:"owner"`
	Signature []byte       `json:"signature"`
	Timestamp uint64       `json:"timestamp"`
	Type      UserNameType `json:"type"`
}

// UserNameType defines model for UserNameType.
type UserNameType string

// UsernameProofsResponse defines model for UsernameProofsResponse.
type UsernameProofsResponse struct {
	Proofs []UserNameProof `json:"proofs"`
}

// ValidateMessageResponse defines model for ValidateMessageResponse.
type ValidateMessageResponse struct {
	// Message *
	// A Message is a delta operation on the Farcaster network. The message protobuf is an envelope
	// that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
	Message Message `json:"message"`
	Valid   bool    `json:"valid"`
}

// Verification defines model for Verification.
type Verification struct {
	Data struct {
		Fid uint64 `json:"fid"`

		// Network Farcaster network the message is intended for.
		// - FARCASTER_NETWORK_MAINNET: Public primary network
		//  - FARCASTER_NETWORK_TESTNET: Public test network
		//  - FARCASTER_NETWORK_DEVNET: Private test network
		Network   FarcasterNetwork `json:"network"`
		Timestamp int64            `json:"timestamp"`

		// Type Type of the MessageBody.
		//  - MESSAGE_TYPE_CAST_ADD: Add a new Cast
		//  - MESSAGE_TYPE_CAST_REMOVE: Remove an existing Cast
		//  - MESSAGE_TYPE_REACTION_ADD: Add a Reaction to a Cast
		//  - MESSAGE_TYPE_REACTION_REMOVE: Remove a Reaction from a Cast
		//  - MESSAGE_TYPE_LINK_ADD: Add a new Link
		//  - MESSAGE_TYPE_LINK_REMOVE: Remove an existing Link
		//  - MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS: Add a Verification of an Ethereum Address
		//  - MESSAGE_TYPE_VERIFICATION_REMOVE: Remove a Verification
		//  - MESSAGE_TYPE_USER_DATA_ADD: Add metadata about a user
		//  - MESSAGE_TYPE_USERNAME_PROOF: Add or replace a username proof
		//  - MESSAGE_TYPE_FRAME_ACTION: A Farcaster Frame action
		Type MessageType `json:"type"`

		// VerificationAddEthAddressBody Adds a Verification of ownership of an Ethereum Address
		VerificationAddEthAddressBody VerificationAddEthAddressBody `json:"verificationAddEthAddressBody"`
	} `json:"data"`
	Hash string `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// VerificationAddEthAddressBody Adds a Verification of ownership of an Ethereum Address
type VerificationAddEthAddressBody struct {
	Address      string `json:"address"`
	BlockHash    string `json:"blockHash"`
	EthSignature []byte `json:"ethSignature"`
}

// VerificationRemove defines model for VerificationRemove.
type VerificationRemove struct {
	Data struct {
		Fid uint64 `json:"fid"`

		// Network Farcaster network the message is intended for.
		// - FARCASTER_NETWORK_MAINNET: Public primary network
		//  - FARCASTER_NETWORK_TESTNET: Public test network
		//  - FARCASTER_NETWORK_DEVNET: Private test network
		Network   FarcasterNetwork `json:"network"`
		Timestamp int64            `json:"timestamp"`

		// Type Type of the MessageBody.
		//  - MESSAGE_TYPE_CAST_ADD: Add a new Cast
		//  - MESSAGE_TYPE_CAST_REMOVE: Remove an existing Cast
		//  - MESSAGE_TYPE_REACTION_ADD: Add a Reaction to a Cast
		//  - MESSAGE_TYPE_REACTION_REMOVE: Remove a Reaction from a Cast
		//  - MESSAGE_TYPE_LINK_ADD: Add a new Link
		//  - MESSAGE_TYPE_LINK_REMOVE: Remove an existing Link
		//  - MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS: Add a Verification of an Ethereum Address
		//  - MESSAGE_TYPE_VERIFICATION_REMOVE: Remove a Verification
		//  - MESSAGE_TYPE_USER_DATA_ADD: Add metadata about a user
		//  - MESSAGE_TYPE_USERNAME_PROOF: Add or replace a username proof
		//  - MESSAGE_TYPE_FRAME_ACTION: A Farcaster Frame action
		Type MessageType `json:"type"`

		// VerificationRemoveBody Removes a Verification of any type
		VerificationRemoveBody VerificationRemoveBody `json:"verificationRemoveBody"`
	} `json:"data"`
	Hash string `json:"hash"`

	// HashScheme Type of hashing scheme used to produce a digest of MessageData. - HASH_SCHEME_BLAKE3: Default scheme for hashing MessageData
	HashScheme HashScheme `json:"hashScheme"`
	Signature  []byte     `json:"signature"`

	// SignatureScheme Type of signature scheme used to sign the Message hash
	// - SIGNATURE_SCHEME_ED25519: Ed25519 signature (default)
	//  - SIGNATURE_SCHEME_EIP712: ECDSA signature using EIP-712 scheme
	SignatureScheme SignatureScheme `json:"signatureScheme"`
	Signer          string          `json:"signer"`
}

// VerificationRemoveBody Removes a Verification of any type
type VerificationRemoveBody struct {
	Address string `json:"address"`
}

// PageSize defines model for pageSize.
type PageSize = int

// PageToken defines model for pageToken.
type PageToken = string

// PaginationReverse defines model for paginationReverse.
type PaginationReverse = bool

// GetCastByIdParams defines parameters for GetCastById.
type GetCastByIdParams struct {
	// Fid The FID of the cast's creator
	Fid int `form:"fid" json:"fid"`

	// Hash The cast's hash
	Hash string `form:"hash" json:"hash"`
}

// ListCastsByFidParams defines parameters for ListCastsByFid.
type ListCastsByFidParams struct {
	// Fid The FID of the casts' creator
	Fid int `form:"fid" json:"fid"`

	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListCastsByMentionParams defines parameters for ListCastsByMention.
type ListCastsByMentionParams struct {
	// Fid The FID that is mentioned in a cast
	Fid int `form:"fid" json:"fid"`

	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListCastsByParentParams defines parameters for ListCastsByParent.
type ListCastsByParentParams struct {
	// Fid The FID of the parent cast
	Fid *int `form:"fid,omitempty" json:"fid,omitempty"`

	// Hash The parent cast's hash
	Hash *string `form:"hash,omitempty" json:"hash,omitempty"`
	Url  *string `form:"url,omitempty" json:"url,omitempty"`

	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetEventByIdParams defines parameters for GetEventById.
type GetEventByIdParams struct {
	// EventId The Hub Id of the event
	EventId int `form:"event_id" json:"event_id"`
}

// ListEventsParams defines parameters for ListEvents.
type ListEventsParams struct {
	// FromEventId An optional Hub Id to start getting events from. This is also returned from the API as nextPageEventId, which can be used to page through all the Hub events. Set it to 0 to start from the first event
	FromEventId *int `form:"from_event_id,omitempty" json:"from_event_id,omitempty"`
}

// ListFidsParams defines parameters for ListFids.
type ListFidsParams struct {
	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetInfoParams defines parameters for GetInfo.
type GetInfoParams struct {
	// Dbstats Whether to return DB stats
	Dbstats bool `form:"dbstats" json:"dbstats"`
}

// GetLinkByIdParams defines parameters for GetLinkById.
type GetLinkByIdParams struct {
	// Fid The FID of the link's originator
	Fid int `form:"fid" json:"fid"`

	// TargetFid The FID of the target of the link
	TargetFid int `form:"target_fid" json:"target_fid"`

	// LinkType The type of link, as a string value
	LinkType LinkType `form:"link_type" json:"link_type"`
}

// ListLinksByFidParams defines parameters for ListLinksByFid.
type ListLinksByFidParams struct {
	// Fid The FID of the link's originator
	Fid int `form:"fid" json:"fid"`

	// LinkType The type of link, as a string value
	LinkType *LinkType `form:"link_type,omitempty" json:"link_type,omitempty"`

	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListLinksByTargetFidParams defines parameters for ListLinksByTargetFid.
type ListLinksByTargetFidParams struct {
	// TargetFid The FID of the target of the link
	TargetFid int `form:"target_fid" json:"target_fid"`

	// LinkType The type of link, as a string value
	LinkType *LinkType `form:"link_type,omitempty" json:"link_type,omitempty"`

	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListOnChainEventsByFidParams defines parameters for ListOnChainEventsByFid.
type ListOnChainEventsByFidParams struct {
	// Fid The FID being requested
	Fid int `form:"fid" json:"fid"`

	// EventType The numeric of string value of the event type being requested.
	EventType OnChainEventType `form:"event_type" json:"event_type"`
}

// GetOnChainIdRegistrationByAddressParams defines parameters for GetOnChainIdRegistrationByAddress.
type GetOnChainIdRegistrationByAddressParams struct {
	// Address The ETH address being requested
	Address string `form:"address" json:"address"`
}

// ListOnChainSignersByFidParams defines parameters for ListOnChainSignersByFid.
type ListOnChainSignersByFidParams struct {
	// Fid The FID being requested
	Fid int `form:"fid" json:"fid"`

	// Signer The optional key of signer
	Signer *string `form:"signer,omitempty" json:"signer,omitempty"`
}

// GetReactionByIdParams defines parameters for GetReactionById.
type GetReactionByIdParams struct {
	// Fid The FID of the reaction's creator
	Fid int `form:"fid" json:"fid"`

	// TargetFid The FID of the cast's creator
	TargetFid int `form:"target_fid" json:"target_fid"`

	// TargetHash The cast's hash
	TargetHash string `form:"target_hash" json:"target_hash"`

	// ReactionType The type of reaction, either as a numerical enum value or string representation
	ReactionType ReactionType `form:"reaction_type" json:"reaction_type"`
}

// ListReactionsByCastParams defines parameters for ListReactionsByCast.
type ListReactionsByCastParams struct {
	// TargetFid The FID of the cast's creator
	TargetFid int `form:"target_fid" json:"target_fid"`

	// TargetHash The hash of the cast
	TargetHash string `form:"target_hash" json:"target_hash"`

	// ReactionType The type of reaction, either as a numerical enum value or string representation
	ReactionType ReactionType `form:"reaction_type" json:"reaction_type"`

	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListReactionsByFidParams defines parameters for ListReactionsByFid.
type ListReactionsByFidParams struct {
	// Fid The FID of the reaction's creator
	Fid int `form:"fid" json:"fid"`

	// ReactionType The type of reaction, either as a numerical enum value or string representation
	ReactionType ReactionType `form:"reaction_type" json:"reaction_type"`

	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// ListReactionsByTargetParams defines parameters for ListReactionsByTarget.
type ListReactionsByTargetParams struct {
	// Url The URL of the parent cast
	Url string `form:"url" json:"url"`

	// ReactionType The type of reaction, either as a numerical enum value or string representation
	ReactionType ReactionType `form:"reaction_type" json:"reaction_type"`

	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetStorageLimitsByFidParams defines parameters for GetStorageLimitsByFid.
type GetStorageLimitsByFidParams struct {
	Fid int `form:"fid" json:"fid"`
}

// GetUserDataByFidParams defines parameters for GetUserDataByFid.
type GetUserDataByFidParams struct {
	// Fid The FID that's being requested
	Fid int `form:"fid" json:"fid"`

	// UserDataType The type of user data, either as a numerical value or type string. If this is omitted, all user data for the FID is returned
	UserDataType *UserDataType `form:"user_data_type,omitempty" json:"user_data_type,omitempty"`

	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// GetUsernameProofParams defines parameters for GetUsernameProof.
type GetUsernameProofParams struct {
	// Name The Farcaster username or ENS address
	Name string `form:"name" json:"name"`
}

// ListUsernameProofsByFidParams defines parameters for ListUsernameProofsByFid.
type ListUsernameProofsByFidParams struct {
	// Fid The FID being requested
	Fid int `form:"fid" json:"fid"`
}

// ListVerificationsByFidParams defines parameters for ListVerificationsByFid.
type ListVerificationsByFidParams struct {
	// Fid The FID being requested
	Fid int `form:"fid" json:"fid"`

	// Address The optional ETH address to filter by
	Address *string `form:"address,omitempty" json:"address,omitempty"`

	// PageSize Maximum number of messages to return in a single response
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Reverse Reverse the sort order, returning latest messages first
	Reverse *PaginationReverse `form:"reverse,omitempty" json:"reverse,omitempty"`

	// PageToken The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
	PageToken *PageToken `form:"pageToken,omitempty" json:"pageToken,omitempty"`
}

// AsCastEmbed returns the union data inside the Embed as a CastEmbed
func (t Embed) AsCastEmbed() (CastEmbed, error) {
	var body CastEmbed
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCastEmbed overwrites any union data inside the Embed as the provided CastEmbed
func (t *Embed) FromCastEmbed(v CastEmbed) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCastEmbed performs a merge with any union data inside the Embed, using the provided CastEmbed
func (t *Embed) MergeCastEmbed(v CastEmbed) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUrlEmbed returns the union data inside the Embed as a UrlEmbed
func (t Embed) AsUrlEmbed() (UrlEmbed, error) {
	var body UrlEmbed
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUrlEmbed overwrites any union data inside the Embed as the provided UrlEmbed
func (t *Embed) FromUrlEmbed(v UrlEmbed) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUrlEmbed performs a merge with any union data inside the Embed, using the provided UrlEmbed
func (t *Embed) MergeUrlEmbed(v UrlEmbed) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Embed) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Embed) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHubEventMergeMessage returns the union data inside the HubEvent as a HubEventMergeMessage
func (t HubEvent) AsHubEventMergeMessage() (HubEventMergeMessage, error) {
	var body HubEventMergeMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHubEventMergeMessage overwrites any union data inside the HubEvent as the provided HubEventMergeMessage
func (t *HubEvent) FromHubEventMergeMessage(v HubEventMergeMessage) error {
	v.Type = "HUB_EVENT_TYPE_MERGE_MESSAGE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHubEventMergeMessage performs a merge with any union data inside the HubEvent, using the provided HubEventMergeMessage
func (t *HubEvent) MergeHubEventMergeMessage(v HubEventMergeMessage) error {
	v.Type = "HUB_EVENT_TYPE_MERGE_MESSAGE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHubEventPruneMessage returns the union data inside the HubEvent as a HubEventPruneMessage
func (t HubEvent) AsHubEventPruneMessage() (HubEventPruneMessage, error) {
	var body HubEventPruneMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHubEventPruneMessage overwrites any union data inside the HubEvent as the provided HubEventPruneMessage
func (t *HubEvent) FromHubEventPruneMessage(v HubEventPruneMessage) error {
	v.Type = "HUB_EVENT_TYPE_PRUNE_MESSAGE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHubEventPruneMessage performs a merge with any union data inside the HubEvent, using the provided HubEventPruneMessage
func (t *HubEvent) MergeHubEventPruneMessage(v HubEventPruneMessage) error {
	v.Type = "HUB_EVENT_TYPE_PRUNE_MESSAGE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHubEventRevokeMessage returns the union data inside the HubEvent as a HubEventRevokeMessage
func (t HubEvent) AsHubEventRevokeMessage() (HubEventRevokeMessage, error) {
	var body HubEventRevokeMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHubEventRevokeMessage overwrites any union data inside the HubEvent as the provided HubEventRevokeMessage
func (t *HubEvent) FromHubEventRevokeMessage(v HubEventRevokeMessage) error {
	v.Type = "HUB_EVENT_TYPE_REVOKE_MESSAGE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHubEventRevokeMessage performs a merge with any union data inside the HubEvent, using the provided HubEventRevokeMessage
func (t *HubEvent) MergeHubEventRevokeMessage(v HubEventRevokeMessage) error {
	v.Type = "HUB_EVENT_TYPE_REVOKE_MESSAGE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHubEventMergeUsernameProof returns the union data inside the HubEvent as a HubEventMergeUsernameProof
func (t HubEvent) AsHubEventMergeUsernameProof() (HubEventMergeUsernameProof, error) {
	var body HubEventMergeUsernameProof
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHubEventMergeUsernameProof overwrites any union data inside the HubEvent as the provided HubEventMergeUsernameProof
func (t *HubEvent) FromHubEventMergeUsernameProof(v HubEventMergeUsernameProof) error {
	v.Type = "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHubEventMergeUsernameProof performs a merge with any union data inside the HubEvent, using the provided HubEventMergeUsernameProof
func (t *HubEvent) MergeHubEventMergeUsernameProof(v HubEventMergeUsernameProof) error {
	v.Type = "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHubEventMergeOnChainEvent returns the union data inside the HubEvent as a HubEventMergeOnChainEvent
func (t HubEvent) AsHubEventMergeOnChainEvent() (HubEventMergeOnChainEvent, error) {
	var body HubEventMergeOnChainEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHubEventMergeOnChainEvent overwrites any union data inside the HubEvent as the provided HubEventMergeOnChainEvent
func (t *HubEvent) FromHubEventMergeOnChainEvent(v HubEventMergeOnChainEvent) error {
	v.Type = "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHubEventMergeOnChainEvent performs a merge with any union data inside the HubEvent, using the provided HubEventMergeOnChainEvent
func (t *HubEvent) MergeHubEventMergeOnChainEvent(v HubEventMergeOnChainEvent) error {
	v.Type = "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t HubEvent) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t HubEvent) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "HUB_EVENT_TYPE_MERGE_MESSAGE":
		return t.AsHubEventMergeMessage()
	case "HUB_EVENT_TYPE_MERGE_ON_CHAIN_EVENT":
		return t.AsHubEventMergeOnChainEvent()
	case "HUB_EVENT_TYPE_MERGE_USERNAME_PROOF":
		return t.AsHubEventMergeUsernameProof()
	case "HUB_EVENT_TYPE_PRUNE_MESSAGE":
		return t.AsHubEventPruneMessage()
	case "HUB_EVENT_TYPE_REVOKE_MESSAGE":
		return t.AsHubEventRevokeMessage()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t HubEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *HubEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageDataCastAdd returns the union data inside the Message_Data as a MessageDataCastAdd
func (t Message_Data) AsMessageDataCastAdd() (MessageDataCastAdd, error) {
	var body MessageDataCastAdd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageDataCastAdd overwrites any union data inside the Message_Data as the provided MessageDataCastAdd
func (t *Message_Data) FromMessageDataCastAdd(v MessageDataCastAdd) error {
	v.Type = "MESSAGE_TYPE_CAST_ADD"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageDataCastAdd performs a merge with any union data inside the Message_Data, using the provided MessageDataCastAdd
func (t *Message_Data) MergeMessageDataCastAdd(v MessageDataCastAdd) error {
	v.Type = "MESSAGE_TYPE_CAST_ADD"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageDataCastRemove returns the union data inside the Message_Data as a MessageDataCastRemove
func (t Message_Data) AsMessageDataCastRemove() (MessageDataCastRemove, error) {
	var body MessageDataCastRemove
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageDataCastRemove overwrites any union data inside the Message_Data as the provided MessageDataCastRemove
func (t *Message_Data) FromMessageDataCastRemove(v MessageDataCastRemove) error {
	v.Type = "MESSAGE_TYPE_CAST_REMOVE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageDataCastRemove performs a merge with any union data inside the Message_Data, using the provided MessageDataCastRemove
func (t *Message_Data) MergeMessageDataCastRemove(v MessageDataCastRemove) error {
	v.Type = "MESSAGE_TYPE_CAST_REMOVE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageDataReaction returns the union data inside the Message_Data as a MessageDataReaction
func (t Message_Data) AsMessageDataReaction() (MessageDataReaction, error) {
	var body MessageDataReaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageDataReaction overwrites any union data inside the Message_Data as the provided MessageDataReaction
func (t *Message_Data) FromMessageDataReaction(v MessageDataReaction) error {
	v.Type = "MESSAGE_TYPE_REACTION_ADD"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageDataReaction performs a merge with any union data inside the Message_Data, using the provided MessageDataReaction
func (t *Message_Data) MergeMessageDataReaction(v MessageDataReaction) error {
	v.Type = "MESSAGE_TYPE_REACTION_ADD"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageDataLink returns the union data inside the Message_Data as a MessageDataLink
func (t Message_Data) AsMessageDataLink() (MessageDataLink, error) {
	var body MessageDataLink
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageDataLink overwrites any union data inside the Message_Data as the provided MessageDataLink
func (t *Message_Data) FromMessageDataLink(v MessageDataLink) error {
	v.Type = "MESSAGE_TYPE_LINK_ADD"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageDataLink performs a merge with any union data inside the Message_Data, using the provided MessageDataLink
func (t *Message_Data) MergeMessageDataLink(v MessageDataLink) error {
	v.Type = "MESSAGE_TYPE_LINK_ADD"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageDataVerificationAdd returns the union data inside the Message_Data as a MessageDataVerificationAdd
func (t Message_Data) AsMessageDataVerificationAdd() (MessageDataVerificationAdd, error) {
	var body MessageDataVerificationAdd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageDataVerificationAdd overwrites any union data inside the Message_Data as the provided MessageDataVerificationAdd
func (t *Message_Data) FromMessageDataVerificationAdd(v MessageDataVerificationAdd) error {
	v.Type = "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageDataVerificationAdd performs a merge with any union data inside the Message_Data, using the provided MessageDataVerificationAdd
func (t *Message_Data) MergeMessageDataVerificationAdd(v MessageDataVerificationAdd) error {
	v.Type = "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageDataVerificationRemove returns the union data inside the Message_Data as a MessageDataVerificationRemove
func (t Message_Data) AsMessageDataVerificationRemove() (MessageDataVerificationRemove, error) {
	var body MessageDataVerificationRemove
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageDataVerificationRemove overwrites any union data inside the Message_Data as the provided MessageDataVerificationRemove
func (t *Message_Data) FromMessageDataVerificationRemove(v MessageDataVerificationRemove) error {
	v.Type = "MESSAGE_TYPE_VERIFICATION_REMOVE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageDataVerificationRemove performs a merge with any union data inside the Message_Data, using the provided MessageDataVerificationRemove
func (t *Message_Data) MergeMessageDataVerificationRemove(v MessageDataVerificationRemove) error {
	v.Type = "MESSAGE_TYPE_VERIFICATION_REMOVE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageDataUserDataAdd returns the union data inside the Message_Data as a MessageDataUserDataAdd
func (t Message_Data) AsMessageDataUserDataAdd() (MessageDataUserDataAdd, error) {
	var body MessageDataUserDataAdd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageDataUserDataAdd overwrites any union data inside the Message_Data as the provided MessageDataUserDataAdd
func (t *Message_Data) FromMessageDataUserDataAdd(v MessageDataUserDataAdd) error {
	v.Type = "MESSAGE_TYPE_USER_DATA_ADD"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageDataUserDataAdd performs a merge with any union data inside the Message_Data, using the provided MessageDataUserDataAdd
func (t *Message_Data) MergeMessageDataUserDataAdd(v MessageDataUserDataAdd) error {
	v.Type = "MESSAGE_TYPE_USER_DATA_ADD"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageDataUsernameProof returns the union data inside the Message_Data as a MessageDataUsernameProof
func (t Message_Data) AsMessageDataUsernameProof() (MessageDataUsernameProof, error) {
	var body MessageDataUsernameProof
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageDataUsernameProof overwrites any union data inside the Message_Data as the provided MessageDataUsernameProof
func (t *Message_Data) FromMessageDataUsernameProof(v MessageDataUsernameProof) error {
	v.Type = "MESSAGE_TYPE_USERNAME_PROOF"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageDataUsernameProof performs a merge with any union data inside the Message_Data, using the provided MessageDataUsernameProof
func (t *Message_Data) MergeMessageDataUsernameProof(v MessageDataUsernameProof) error {
	v.Type = "MESSAGE_TYPE_USERNAME_PROOF"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageDataFrameAction returns the union data inside the Message_Data as a MessageDataFrameAction
func (t Message_Data) AsMessageDataFrameAction() (MessageDataFrameAction, error) {
	var body MessageDataFrameAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageDataFrameAction overwrites any union data inside the Message_Data as the provided MessageDataFrameAction
func (t *Message_Data) FromMessageDataFrameAction(v MessageDataFrameAction) error {
	v.Type = "MESSAGE_TYPE_FRAME_ACTION"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageDataFrameAction performs a merge with any union data inside the Message_Data, using the provided MessageDataFrameAction
func (t *Message_Data) MergeMessageDataFrameAction(v MessageDataFrameAction) error {
	v.Type = "MESSAGE_TYPE_FRAME_ACTION"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Message_Data) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Message_Data) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "MESSAGE_TYPE_CAST_ADD":
		return t.AsMessageDataCastAdd()
	case "MESSAGE_TYPE_CAST_REMOVE":
		return t.AsMessageDataCastRemove()
	case "MESSAGE_TYPE_FRAME_ACTION":
		return t.AsMessageDataFrameAction()
	case "MESSAGE_TYPE_LINK_ADD":
		return t.AsMessageDataLink()
	case "MESSAGE_TYPE_REACTION_ADD":
		return t.AsMessageDataReaction()
	case "MESSAGE_TYPE_USERNAME_PROOF":
		return t.AsMessageDataUsernameProof()
	case "MESSAGE_TYPE_USER_DATA_ADD":
		return t.AsMessageDataUserDataAdd()
	case "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS":
		return t.AsMessageDataVerificationAdd()
	case "MESSAGE_TYPE_VERIFICATION_REMOVE":
		return t.AsMessageDataVerificationRemove()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Message_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Message_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOnChainEventSigner returns the union data inside the OnChainEvent as a OnChainEventSigner
func (t OnChainEvent) AsOnChainEventSigner() (OnChainEventSigner, error) {
	var body OnChainEventSigner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOnChainEventSigner overwrites any union data inside the OnChainEvent as the provided OnChainEventSigner
func (t *OnChainEvent) FromOnChainEventSigner(v OnChainEventSigner) error {
	v.Type = "EVENT_TYPE_SIGNER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOnChainEventSigner performs a merge with any union data inside the OnChainEvent, using the provided OnChainEventSigner
func (t *OnChainEvent) MergeOnChainEventSigner(v OnChainEventSigner) error {
	v.Type = "EVENT_TYPE_SIGNER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOnChainEventSignerMigrated returns the union data inside the OnChainEvent as a OnChainEventSignerMigrated
func (t OnChainEvent) AsOnChainEventSignerMigrated() (OnChainEventSignerMigrated, error) {
	var body OnChainEventSignerMigrated
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOnChainEventSignerMigrated overwrites any union data inside the OnChainEvent as the provided OnChainEventSignerMigrated
func (t *OnChainEvent) FromOnChainEventSignerMigrated(v OnChainEventSignerMigrated) error {
	v.Type = "EVENT_TYPE_SIGNER_MIGRATED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOnChainEventSignerMigrated performs a merge with any union data inside the OnChainEvent, using the provided OnChainEventSignerMigrated
func (t *OnChainEvent) MergeOnChainEventSignerMigrated(v OnChainEventSignerMigrated) error {
	v.Type = "EVENT_TYPE_SIGNER_MIGRATED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOnChainEventIdRegister returns the union data inside the OnChainEvent as a OnChainEventIdRegister
func (t OnChainEvent) AsOnChainEventIdRegister() (OnChainEventIdRegister, error) {
	var body OnChainEventIdRegister
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOnChainEventIdRegister overwrites any union data inside the OnChainEvent as the provided OnChainEventIdRegister
func (t *OnChainEvent) FromOnChainEventIdRegister(v OnChainEventIdRegister) error {
	v.Type = "EVENT_TYPE_ID_REGISTER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOnChainEventIdRegister performs a merge with any union data inside the OnChainEvent, using the provided OnChainEventIdRegister
func (t *OnChainEvent) MergeOnChainEventIdRegister(v OnChainEventIdRegister) error {
	v.Type = "EVENT_TYPE_ID_REGISTER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOnChainEventStorageRent returns the union data inside the OnChainEvent as a OnChainEventStorageRent
func (t OnChainEvent) AsOnChainEventStorageRent() (OnChainEventStorageRent, error) {
	var body OnChainEventStorageRent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOnChainEventStorageRent overwrites any union data inside the OnChainEvent as the provided OnChainEventStorageRent
func (t *OnChainEvent) FromOnChainEventStorageRent(v OnChainEventStorageRent) error {
	v.Type = "EVENT_TYPE_STORAGE_RENT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOnChainEventStorageRent performs a merge with any union data inside the OnChainEvent, using the provided OnChainEventStorageRent
func (t *OnChainEvent) MergeOnChainEventStorageRent(v OnChainEventStorageRent) error {
	v.Type = "EVENT_TYPE_STORAGE_RENT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OnChainEvent) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OnChainEvent) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "EVENT_TYPE_ID_REGISTER":
		return t.AsOnChainEventIdRegister()
	case "EVENT_TYPE_SIGNER":
		return t.AsOnChainEventSigner()
	case "EVENT_TYPE_SIGNER_MIGRATED":
		return t.AsOnChainEventSignerMigrated()
	case "EVENT_TYPE_STORAGE_RENT":
		return t.AsOnChainEventStorageRent()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OnChainEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OnChainEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCastById request
	GetCastById(ctx context.Context, params *GetCastByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCastsByFid request
	ListCastsByFid(ctx context.Context, params *ListCastsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCastsByMention request
	ListCastsByMention(ctx context.Context, params *ListCastsByMentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCastsByParent request
	ListCastsByParent(ctx context.Context, params *ListCastsByParentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventById request
	GetEventById(ctx context.Context, params *GetEventByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvents request
	ListEvents(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFids request
	ListFids(ctx context.Context, params *ListFidsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfo request
	GetInfo(ctx context.Context, params *GetInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLinkById request
	GetLinkById(ctx context.Context, params *GetLinkByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLinksByFid request
	ListLinksByFid(ctx context.Context, params *ListLinksByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLinksByTargetFid request
	ListLinksByTargetFid(ctx context.Context, params *ListLinksByTargetFidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOnChainEventsByFid request
	ListOnChainEventsByFid(ctx context.Context, params *ListOnChainEventsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOnChainIdRegistrationByAddress request
	GetOnChainIdRegistrationByAddress(ctx context.Context, params *GetOnChainIdRegistrationByAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOnChainSignersByFid request
	ListOnChainSignersByFid(ctx context.Context, params *ListOnChainSignersByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReactionById request
	GetReactionById(ctx context.Context, params *GetReactionByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReactionsByCast request
	ListReactionsByCast(ctx context.Context, params *ListReactionsByCastParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReactionsByFid request
	ListReactionsByFid(ctx context.Context, params *ListReactionsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListReactionsByTarget request
	ListReactionsByTarget(ctx context.Context, params *ListReactionsByTargetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageLimitsByFid request
	GetStorageLimitsByFid(ctx context.Context, params *GetStorageLimitsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitMessageWithBody request with any body
	SubmitMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserDataByFid request
	GetUserDataByFid(ctx context.Context, params *GetUserDataByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsernameProof request
	GetUsernameProof(ctx context.Context, params *GetUsernameProofParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsernameProofsByFid request
	ListUsernameProofsByFid(ctx context.Context, params *ListUsernameProofsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateMessageWithBody request with any body
	ValidateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVerificationsByFid request
	ListVerificationsByFid(ctx context.Context, params *ListVerificationsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCastById(ctx context.Context, params *GetCastByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCastByIdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCastsByFid(ctx context.Context, params *ListCastsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCastsByFidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCastsByMention(ctx context.Context, params *ListCastsByMentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCastsByMentionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCastsByParent(ctx context.Context, params *ListCastsByParentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCastsByParentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventById(ctx context.Context, params *GetEventByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventByIdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEvents(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFids(ctx context.Context, params *ListFidsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFidsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfo(ctx context.Context, params *GetInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLinkById(ctx context.Context, params *GetLinkByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLinkByIdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLinksByFid(ctx context.Context, params *ListLinksByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLinksByFidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLinksByTargetFid(ctx context.Context, params *ListLinksByTargetFidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLinksByTargetFidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOnChainEventsByFid(ctx context.Context, params *ListOnChainEventsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOnChainEventsByFidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOnChainIdRegistrationByAddress(ctx context.Context, params *GetOnChainIdRegistrationByAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOnChainIdRegistrationByAddressRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOnChainSignersByFid(ctx context.Context, params *ListOnChainSignersByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOnChainSignersByFidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReactionById(ctx context.Context, params *GetReactionByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReactionByIdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReactionsByCast(ctx context.Context, params *ListReactionsByCastParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReactionsByCastRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReactionsByFid(ctx context.Context, params *ListReactionsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReactionsByFidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListReactionsByTarget(ctx context.Context, params *ListReactionsByTargetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListReactionsByTargetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageLimitsByFid(ctx context.Context, params *GetStorageLimitsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageLimitsByFidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserDataByFid(ctx context.Context, params *GetUserDataByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserDataByFidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsernameProof(ctx context.Context, params *GetUsernameProofParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsernameProofRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsernameProofsByFid(ctx context.Context, params *ListUsernameProofsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsernameProofsByFidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVerificationsByFid(ctx context.Context, params *ListVerificationsByFidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVerificationsByFidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCastByIdRequest generates requests for GetCastById
func NewGetCastByIdRequest(server string, params *GetCastByIdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/castById")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hash", runtime.ParamLocationQuery, params.Hash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCastsByFidRequest generates requests for ListCastsByFid
func NewListCastsByFidRequest(server string, params *ListCastsByFidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/castsByFid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCastsByMentionRequest generates requests for ListCastsByMention
func NewListCastsByMentionRequest(server string, params *ListCastsByMentionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/castsByMention")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCastsByParentRequest generates requests for ListCastsByParent
func NewListCastsByParentRequest(server string, params *ListCastsByParentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/castsByParent")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, *params.Fid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hash", runtime.ParamLocationQuery, *params.Hash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Url != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, *params.Url); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventByIdRequest generates requests for GetEventById
func NewGetEventByIdRequest(server string, params *GetEventByIdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/eventById")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, params.EventId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventsRequest generates requests for ListEvents
func NewListEventsRequest(server string, params *ListEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromEventId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_event_id", runtime.ParamLocationQuery, *params.FromEventId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFidsRequest generates requests for ListFids
func NewListFidsRequest(server string, params *ListFidsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/fids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInfoRequest generates requests for GetInfo
func NewGetInfoRequest(server string, params *GetInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dbstats", runtime.ParamLocationQuery, params.Dbstats); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLinkByIdRequest generates requests for GetLinkById
func NewGetLinkByIdRequest(server string, params *GetLinkByIdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/linkById")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_fid", runtime.ParamLocationQuery, params.TargetFid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "link_type", runtime.ParamLocationQuery, params.LinkType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLinksByFidRequest generates requests for ListLinksByFid
func NewListLinksByFidRequest(server string, params *ListLinksByFidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/linksByFid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LinkType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "link_type", runtime.ParamLocationQuery, *params.LinkType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLinksByTargetFidRequest generates requests for ListLinksByTargetFid
func NewListLinksByTargetFidRequest(server string, params *ListLinksByTargetFidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/linksByTargetFid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_fid", runtime.ParamLocationQuery, params.TargetFid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LinkType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "link_type", runtime.ParamLocationQuery, *params.LinkType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOnChainEventsByFidRequest generates requests for ListOnChainEventsByFid
func NewListOnChainEventsByFidRequest(server string, params *ListOnChainEventsByFidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/onChainEventsByFid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_type", runtime.ParamLocationQuery, params.EventType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOnChainIdRegistrationByAddressRequest generates requests for GetOnChainIdRegistrationByAddress
func NewGetOnChainIdRegistrationByAddressRequest(server string, params *GetOnChainIdRegistrationByAddressParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/onChainIdRegistryEventByAddress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, params.Address); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOnChainSignersByFidRequest generates requests for ListOnChainSignersByFid
func NewListOnChainSignersByFidRequest(server string, params *ListOnChainSignersByFidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/onChainSignersByFid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Signer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signer", runtime.ParamLocationQuery, *params.Signer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReactionByIdRequest generates requests for GetReactionById
func NewGetReactionByIdRequest(server string, params *GetReactionByIdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/reactionById")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_fid", runtime.ParamLocationQuery, params.TargetFid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_hash", runtime.ParamLocationQuery, params.TargetHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reaction_type", runtime.ParamLocationQuery, params.ReactionType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListReactionsByCastRequest generates requests for ListReactionsByCast
func NewListReactionsByCastRequest(server string, params *ListReactionsByCastParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/reactionsByCast")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_fid", runtime.ParamLocationQuery, params.TargetFid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_hash", runtime.ParamLocationQuery, params.TargetHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reaction_type", runtime.ParamLocationQuery, params.ReactionType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListReactionsByFidRequest generates requests for ListReactionsByFid
func NewListReactionsByFidRequest(server string, params *ListReactionsByFidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/reactionsByFid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reaction_type", runtime.ParamLocationQuery, params.ReactionType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListReactionsByTargetRequest generates requests for ListReactionsByTarget
func NewListReactionsByTargetRequest(server string, params *ListReactionsByTargetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/reactionsByTarget")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reaction_type", runtime.ParamLocationQuery, params.ReactionType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageLimitsByFidRequest generates requests for GetStorageLimitsByFid
func NewGetStorageLimitsByFidRequest(server string, params *GetStorageLimitsByFidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/storageLimitsByFid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitMessageRequestWithBody generates requests for SubmitMessage with any type of body
func NewSubmitMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/submitMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserDataByFidRequest generates requests for GetUserDataByFid
func NewGetUserDataByFidRequest(server string, params *GetUserDataByFidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/userDataByFid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserDataType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_data_type", runtime.ParamLocationQuery, *params.UserDataType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsernameProofRequest generates requests for GetUsernameProof
func NewGetUsernameProofRequest(server string, params *GetUsernameProofParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/userNameProofByName")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsernameProofsByFidRequest generates requests for ListUsernameProofsByFid
func NewListUsernameProofsByFidRequest(server string, params *ListUsernameProofsByFidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/userNameProofsByFid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewValidateMessageRequestWithBody generates requests for ValidateMessage with any type of body
func NewValidateMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/validateMessage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVerificationsByFidRequest generates requests for ListVerificationsByFid
func NewListVerificationsByFidRequest(server string, params *ListVerificationsByFidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/verificationsByFid")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fid", runtime.ParamLocationQuery, params.Fid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Address != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, *params.Address); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reverse", runtime.ParamLocationQuery, *params.Reverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageToken", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCastByIdWithResponse request
	GetCastByIdWithResponse(ctx context.Context, params *GetCastByIdParams, reqEditors ...RequestEditorFn) (*GetCastByIdResp, error)

	// ListCastsByFidWithResponse request
	ListCastsByFidWithResponse(ctx context.Context, params *ListCastsByFidParams, reqEditors ...RequestEditorFn) (*ListCastsByFidResp, error)

	// ListCastsByMentionWithResponse request
	ListCastsByMentionWithResponse(ctx context.Context, params *ListCastsByMentionParams, reqEditors ...RequestEditorFn) (*ListCastsByMentionResp, error)

	// ListCastsByParentWithResponse request
	ListCastsByParentWithResponse(ctx context.Context, params *ListCastsByParentParams, reqEditors ...RequestEditorFn) (*ListCastsByParentResp, error)

	// GetEventByIdWithResponse request
	GetEventByIdWithResponse(ctx context.Context, params *GetEventByIdParams, reqEditors ...RequestEditorFn) (*GetEventByIdResp, error)

	// ListEventsWithResponse request
	ListEventsWithResponse(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResp, error)

	// ListFidsWithResponse request
	ListFidsWithResponse(ctx context.Context, params *ListFidsParams, reqEditors ...RequestEditorFn) (*ListFidsResp, error)

	// GetInfoWithResponse request
	GetInfoWithResponse(ctx context.Context, params *GetInfoParams, reqEditors ...RequestEditorFn) (*GetInfoResp, error)

	// GetLinkByIdWithResponse request
	GetLinkByIdWithResponse(ctx context.Context, params *GetLinkByIdParams, reqEditors ...RequestEditorFn) (*GetLinkByIdResp, error)

	// ListLinksByFidWithResponse request
	ListLinksByFidWithResponse(ctx context.Context, params *ListLinksByFidParams, reqEditors ...RequestEditorFn) (*ListLinksByFidResp, error)

	// ListLinksByTargetFidWithResponse request
	ListLinksByTargetFidWithResponse(ctx context.Context, params *ListLinksByTargetFidParams, reqEditors ...RequestEditorFn) (*ListLinksByTargetFidResp, error)

	// ListOnChainEventsByFidWithResponse request
	ListOnChainEventsByFidWithResponse(ctx context.Context, params *ListOnChainEventsByFidParams, reqEditors ...RequestEditorFn) (*ListOnChainEventsByFidResp, error)

	// GetOnChainIdRegistrationByAddressWithResponse request
	GetOnChainIdRegistrationByAddressWithResponse(ctx context.Context, params *GetOnChainIdRegistrationByAddressParams, reqEditors ...RequestEditorFn) (*GetOnChainIdRegistrationByAddressResp, error)

	// ListOnChainSignersByFidWithResponse request
	ListOnChainSignersByFidWithResponse(ctx context.Context, params *ListOnChainSignersByFidParams, reqEditors ...RequestEditorFn) (*ListOnChainSignersByFidResp, error)

	// GetReactionByIdWithResponse request
	GetReactionByIdWithResponse(ctx context.Context, params *GetReactionByIdParams, reqEditors ...RequestEditorFn) (*GetReactionByIdResp, error)

	// ListReactionsByCastWithResponse request
	ListReactionsByCastWithResponse(ctx context.Context, params *ListReactionsByCastParams, reqEditors ...RequestEditorFn) (*ListReactionsByCastResp, error)

	// ListReactionsByFidWithResponse request
	ListReactionsByFidWithResponse(ctx context.Context, params *ListReactionsByFidParams, reqEditors ...RequestEditorFn) (*ListReactionsByFidResp, error)

	// ListReactionsByTargetWithResponse request
	ListReactionsByTargetWithResponse(ctx context.Context, params *ListReactionsByTargetParams, reqEditors ...RequestEditorFn) (*ListReactionsByTargetResp, error)

	// GetStorageLimitsByFidWithResponse request
	GetStorageLimitsByFidWithResponse(ctx context.Context, params *GetStorageLimitsByFidParams, reqEditors ...RequestEditorFn) (*GetStorageLimitsByFidResp, error)

	// SubmitMessageWithBodyWithResponse request with any body
	SubmitMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitMessageResp, error)

	// GetUserDataByFidWithResponse request
	GetUserDataByFidWithResponse(ctx context.Context, params *GetUserDataByFidParams, reqEditors ...RequestEditorFn) (*GetUserDataByFidResp, error)

	// GetUsernameProofWithResponse request
	GetUsernameProofWithResponse(ctx context.Context, params *GetUsernameProofParams, reqEditors ...RequestEditorFn) (*GetUsernameProofResp, error)

	// ListUsernameProofsByFidWithResponse request
	ListUsernameProofsByFidWithResponse(ctx context.Context, params *ListUsernameProofsByFidParams, reqEditors ...RequestEditorFn) (*ListUsernameProofsByFidResp, error)

	// ValidateMessageWithBodyWithResponse request with any body
	ValidateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateMessageResp, error)

	// ListVerificationsByFidWithResponse request
	ListVerificationsByFidWithResponse(ctx context.Context, params *ListVerificationsByFidParams, reqEditors ...RequestEditorFn) (*ListVerificationsByFidResp, error)
}

type GetCastByIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CastAdd
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCastByIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCastByIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCastsByFidResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages      []CastAdd `json:"messages"`
		NextPageToken []byte    `json:"nextPageToken"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListCastsByFidResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCastsByFidResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCastsByMentionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages      []CastAdd `json:"messages"`
		NextPageToken []byte    `json:"nextPageToken"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListCastsByMentionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCastsByMentionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCastsByParentResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages      []CastAdd `json:"messages"`
		NextPageToken []byte    `json:"nextPageToken"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListCastsByParentResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCastsByParentResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventByIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HubEvent
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetEventByIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventByIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Events          []HubEvent `json:"events"`
		NextPageEventId int        `json:"nextPageEventId"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListEventsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFidsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FidsResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListFidsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFidsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HubInfoResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLinkByIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkAdd
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLinkByIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLinkByIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLinksByFidResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages      []LinkAdd `json:"messages"`
		NextPageToken []byte    `json:"nextPageToken"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListLinksByFidResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLinksByFidResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLinksByTargetFidResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages      []LinkAdd `json:"messages"`
		NextPageToken []byte    `json:"nextPageToken"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListLinksByTargetFidResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLinksByTargetFidResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOnChainEventsByFidResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Events []OnChainEvent `json:"events"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListOnChainEventsByFidResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOnChainEventsByFidResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOnChainIdRegistrationByAddressResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OnChainEventIdRegister
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetOnChainIdRegistrationByAddressResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOnChainIdRegistrationByAddressResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOnChainSignersByFidResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListOnChainSignersByFidResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOnChainSignersByFidResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReactionByIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reaction
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetReactionByIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReactionByIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReactionsByCastResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages      []Reaction `json:"messages"`
		NextPageToken []byte     `json:"nextPageToken"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListReactionsByCastResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReactionsByCastResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReactionsByFidResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages      []Reaction `json:"messages"`
		NextPageToken []byte     `json:"nextPageToken"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListReactionsByFidResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReactionsByFidResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListReactionsByTargetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages      []Reaction `json:"messages"`
		NextPageToken []byte     `json:"nextPageToken"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListReactionsByTargetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListReactionsByTargetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageLimitsByFidResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageLimitsResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetStorageLimitsByFidResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageLimitsByFidResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Message
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SubmitMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserDataByFidResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUserDataByFidResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserDataByFidResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsernameProofResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserNameProof
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUsernameProofResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsernameProofResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsernameProofsByFidResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsernameProofsResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListUsernameProofsByFidResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsernameProofsByFidResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidateMessageResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ValidateMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVerificationsByFidResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages      []Verification `json:"messages"`
		NextPageToken []byte         `json:"nextPageToken"`
	}
	JSONDefault *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListVerificationsByFidResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVerificationsByFidResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCastByIdWithResponse request returning *GetCastByIdResp
func (c *ClientWithResponses) GetCastByIdWithResponse(ctx context.Context, params *GetCastByIdParams, reqEditors ...RequestEditorFn) (*GetCastByIdResp, error) {
	rsp, err := c.GetCastById(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCastByIdResp(rsp)
}

// ListCastsByFidWithResponse request returning *ListCastsByFidResp
func (c *ClientWithResponses) ListCastsByFidWithResponse(ctx context.Context, params *ListCastsByFidParams, reqEditors ...RequestEditorFn) (*ListCastsByFidResp, error) {
	rsp, err := c.ListCastsByFid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCastsByFidResp(rsp)
}

// ListCastsByMentionWithResponse request returning *ListCastsByMentionResp
func (c *ClientWithResponses) ListCastsByMentionWithResponse(ctx context.Context, params *ListCastsByMentionParams, reqEditors ...RequestEditorFn) (*ListCastsByMentionResp, error) {
	rsp, err := c.ListCastsByMention(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCastsByMentionResp(rsp)
}

// ListCastsByParentWithResponse request returning *ListCastsByParentResp
func (c *ClientWithResponses) ListCastsByParentWithResponse(ctx context.Context, params *ListCastsByParentParams, reqEditors ...RequestEditorFn) (*ListCastsByParentResp, error) {
	rsp, err := c.ListCastsByParent(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCastsByParentResp(rsp)
}

// GetEventByIdWithResponse request returning *GetEventByIdResp
func (c *ClientWithResponses) GetEventByIdWithResponse(ctx context.Context, params *GetEventByIdParams, reqEditors ...RequestEditorFn) (*GetEventByIdResp, error) {
	rsp, err := c.GetEventById(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventByIdResp(rsp)
}

// ListEventsWithResponse request returning *ListEventsResp
func (c *ClientWithResponses) ListEventsWithResponse(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResp, error) {
	rsp, err := c.ListEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsResp(rsp)
}

// ListFidsWithResponse request returning *ListFidsResp
func (c *ClientWithResponses) ListFidsWithResponse(ctx context.Context, params *ListFidsParams, reqEditors ...RequestEditorFn) (*ListFidsResp, error) {
	rsp, err := c.ListFids(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFidsResp(rsp)
}

// GetInfoWithResponse request returning *GetInfoResp
func (c *ClientWithResponses) GetInfoWithResponse(ctx context.Context, params *GetInfoParams, reqEditors ...RequestEditorFn) (*GetInfoResp, error) {
	rsp, err := c.GetInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfoResp(rsp)
}

// GetLinkByIdWithResponse request returning *GetLinkByIdResp
func (c *ClientWithResponses) GetLinkByIdWithResponse(ctx context.Context, params *GetLinkByIdParams, reqEditors ...RequestEditorFn) (*GetLinkByIdResp, error) {
	rsp, err := c.GetLinkById(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLinkByIdResp(rsp)
}

// ListLinksByFidWithResponse request returning *ListLinksByFidResp
func (c *ClientWithResponses) ListLinksByFidWithResponse(ctx context.Context, params *ListLinksByFidParams, reqEditors ...RequestEditorFn) (*ListLinksByFidResp, error) {
	rsp, err := c.ListLinksByFid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLinksByFidResp(rsp)
}

// ListLinksByTargetFidWithResponse request returning *ListLinksByTargetFidResp
func (c *ClientWithResponses) ListLinksByTargetFidWithResponse(ctx context.Context, params *ListLinksByTargetFidParams, reqEditors ...RequestEditorFn) (*ListLinksByTargetFidResp, error) {
	rsp, err := c.ListLinksByTargetFid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLinksByTargetFidResp(rsp)
}

// ListOnChainEventsByFidWithResponse request returning *ListOnChainEventsByFidResp
func (c *ClientWithResponses) ListOnChainEventsByFidWithResponse(ctx context.Context, params *ListOnChainEventsByFidParams, reqEditors ...RequestEditorFn) (*ListOnChainEventsByFidResp, error) {
	rsp, err := c.ListOnChainEventsByFid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOnChainEventsByFidResp(rsp)
}

// GetOnChainIdRegistrationByAddressWithResponse request returning *GetOnChainIdRegistrationByAddressResp
func (c *ClientWithResponses) GetOnChainIdRegistrationByAddressWithResponse(ctx context.Context, params *GetOnChainIdRegistrationByAddressParams, reqEditors ...RequestEditorFn) (*GetOnChainIdRegistrationByAddressResp, error) {
	rsp, err := c.GetOnChainIdRegistrationByAddress(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOnChainIdRegistrationByAddressResp(rsp)
}

// ListOnChainSignersByFidWithResponse request returning *ListOnChainSignersByFidResp
func (c *ClientWithResponses) ListOnChainSignersByFidWithResponse(ctx context.Context, params *ListOnChainSignersByFidParams, reqEditors ...RequestEditorFn) (*ListOnChainSignersByFidResp, error) {
	rsp, err := c.ListOnChainSignersByFid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOnChainSignersByFidResp(rsp)
}

// GetReactionByIdWithResponse request returning *GetReactionByIdResp
func (c *ClientWithResponses) GetReactionByIdWithResponse(ctx context.Context, params *GetReactionByIdParams, reqEditors ...RequestEditorFn) (*GetReactionByIdResp, error) {
	rsp, err := c.GetReactionById(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReactionByIdResp(rsp)
}

// ListReactionsByCastWithResponse request returning *ListReactionsByCastResp
func (c *ClientWithResponses) ListReactionsByCastWithResponse(ctx context.Context, params *ListReactionsByCastParams, reqEditors ...RequestEditorFn) (*ListReactionsByCastResp, error) {
	rsp, err := c.ListReactionsByCast(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReactionsByCastResp(rsp)
}

// ListReactionsByFidWithResponse request returning *ListReactionsByFidResp
func (c *ClientWithResponses) ListReactionsByFidWithResponse(ctx context.Context, params *ListReactionsByFidParams, reqEditors ...RequestEditorFn) (*ListReactionsByFidResp, error) {
	rsp, err := c.ListReactionsByFid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReactionsByFidResp(rsp)
}

// ListReactionsByTargetWithResponse request returning *ListReactionsByTargetResp
func (c *ClientWithResponses) ListReactionsByTargetWithResponse(ctx context.Context, params *ListReactionsByTargetParams, reqEditors ...RequestEditorFn) (*ListReactionsByTargetResp, error) {
	rsp, err := c.ListReactionsByTarget(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListReactionsByTargetResp(rsp)
}

// GetStorageLimitsByFidWithResponse request returning *GetStorageLimitsByFidResp
func (c *ClientWithResponses) GetStorageLimitsByFidWithResponse(ctx context.Context, params *GetStorageLimitsByFidParams, reqEditors ...RequestEditorFn) (*GetStorageLimitsByFidResp, error) {
	rsp, err := c.GetStorageLimitsByFid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageLimitsByFidResp(rsp)
}

// SubmitMessageWithBodyWithResponse request with arbitrary body returning *SubmitMessageResp
func (c *ClientWithResponses) SubmitMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitMessageResp, error) {
	rsp, err := c.SubmitMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitMessageResp(rsp)
}

// GetUserDataByFidWithResponse request returning *GetUserDataByFidResp
func (c *ClientWithResponses) GetUserDataByFidWithResponse(ctx context.Context, params *GetUserDataByFidParams, reqEditors ...RequestEditorFn) (*GetUserDataByFidResp, error) {
	rsp, err := c.GetUserDataByFid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserDataByFidResp(rsp)
}

// GetUsernameProofWithResponse request returning *GetUsernameProofResp
func (c *ClientWithResponses) GetUsernameProofWithResponse(ctx context.Context, params *GetUsernameProofParams, reqEditors ...RequestEditorFn) (*GetUsernameProofResp, error) {
	rsp, err := c.GetUsernameProof(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsernameProofResp(rsp)
}

// ListUsernameProofsByFidWithResponse request returning *ListUsernameProofsByFidResp
func (c *ClientWithResponses) ListUsernameProofsByFidWithResponse(ctx context.Context, params *ListUsernameProofsByFidParams, reqEditors ...RequestEditorFn) (*ListUsernameProofsByFidResp, error) {
	rsp, err := c.ListUsernameProofsByFid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsernameProofsByFidResp(rsp)
}

// ValidateMessageWithBodyWithResponse request with arbitrary body returning *ValidateMessageResp
func (c *ClientWithResponses) ValidateMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateMessageResp, error) {
	rsp, err := c.ValidateMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateMessageResp(rsp)
}

// ListVerificationsByFidWithResponse request returning *ListVerificationsByFidResp
func (c *ClientWithResponses) ListVerificationsByFidWithResponse(ctx context.Context, params *ListVerificationsByFidParams, reqEditors ...RequestEditorFn) (*ListVerificationsByFidResp, error) {
	rsp, err := c.ListVerificationsByFid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVerificationsByFidResp(rsp)
}

// ParseGetCastByIdResp parses an HTTP response from a GetCastByIdWithResponse call
func ParseGetCastByIdResp(rsp *http.Response) (*GetCastByIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCastByIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CastAdd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCastsByFidResp parses an HTTP response from a ListCastsByFidWithResponse call
func ParseListCastsByFidResp(rsp *http.Response) (*ListCastsByFidResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCastsByFidResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages      []CastAdd `json:"messages"`
			NextPageToken []byte    `json:"nextPageToken"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCastsByMentionResp parses an HTTP response from a ListCastsByMentionWithResponse call
func ParseListCastsByMentionResp(rsp *http.Response) (*ListCastsByMentionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCastsByMentionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages      []CastAdd `json:"messages"`
			NextPageToken []byte    `json:"nextPageToken"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCastsByParentResp parses an HTTP response from a ListCastsByParentWithResponse call
func ParseListCastsByParentResp(rsp *http.Response) (*ListCastsByParentResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCastsByParentResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages      []CastAdd `json:"messages"`
			NextPageToken []byte    `json:"nextPageToken"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEventByIdResp parses an HTTP response from a GetEventByIdWithResponse call
func ParseGetEventByIdResp(rsp *http.Response) (*GetEventByIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventByIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HubEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListEventsResp parses an HTTP response from a ListEventsWithResponse call
func ParseListEventsResp(rsp *http.Response) (*ListEventsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Events          []HubEvent `json:"events"`
			NextPageEventId int        `json:"nextPageEventId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListFidsResp parses an HTTP response from a ListFidsWithResponse call
func ParseListFidsResp(rsp *http.Response) (*ListFidsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFidsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FidsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInfoResp parses an HTTP response from a GetInfoWithResponse call
func ParseGetInfoResp(rsp *http.Response) (*GetInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HubInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLinkByIdResp parses an HTTP response from a GetLinkByIdWithResponse call
func ParseGetLinkByIdResp(rsp *http.Response) (*GetLinkByIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLinkByIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkAdd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListLinksByFidResp parses an HTTP response from a ListLinksByFidWithResponse call
func ParseListLinksByFidResp(rsp *http.Response) (*ListLinksByFidResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLinksByFidResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages      []LinkAdd `json:"messages"`
			NextPageToken []byte    `json:"nextPageToken"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListLinksByTargetFidResp parses an HTTP response from a ListLinksByTargetFidWithResponse call
func ParseListLinksByTargetFidResp(rsp *http.Response) (*ListLinksByTargetFidResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLinksByTargetFidResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages      []LinkAdd `json:"messages"`
			NextPageToken []byte    `json:"nextPageToken"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListOnChainEventsByFidResp parses an HTTP response from a ListOnChainEventsByFidWithResponse call
func ParseListOnChainEventsByFidResp(rsp *http.Response) (*ListOnChainEventsByFidResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOnChainEventsByFidResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Events []OnChainEvent `json:"events"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOnChainIdRegistrationByAddressResp parses an HTTP response from a GetOnChainIdRegistrationByAddressWithResponse call
func ParseGetOnChainIdRegistrationByAddressResp(rsp *http.Response) (*GetOnChainIdRegistrationByAddressResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOnChainIdRegistrationByAddressResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OnChainEventIdRegister
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListOnChainSignersByFidResp parses an HTTP response from a ListOnChainSignersByFidWithResponse call
func ParseListOnChainSignersByFidResp(rsp *http.Response) (*ListOnChainSignersByFidResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOnChainSignersByFidResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReactionByIdResp parses an HTTP response from a GetReactionByIdWithResponse call
func ParseGetReactionByIdResp(rsp *http.Response) (*GetReactionByIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReactionByIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListReactionsByCastResp parses an HTTP response from a ListReactionsByCastWithResponse call
func ParseListReactionsByCastResp(rsp *http.Response) (*ListReactionsByCastResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReactionsByCastResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages      []Reaction `json:"messages"`
			NextPageToken []byte     `json:"nextPageToken"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListReactionsByFidResp parses an HTTP response from a ListReactionsByFidWithResponse call
func ParseListReactionsByFidResp(rsp *http.Response) (*ListReactionsByFidResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReactionsByFidResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages      []Reaction `json:"messages"`
			NextPageToken []byte     `json:"nextPageToken"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListReactionsByTargetResp parses an HTTP response from a ListReactionsByTargetWithResponse call
func ParseListReactionsByTargetResp(rsp *http.Response) (*ListReactionsByTargetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListReactionsByTargetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages      []Reaction `json:"messages"`
			NextPageToken []byte     `json:"nextPageToken"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStorageLimitsByFidResp parses an HTTP response from a GetStorageLimitsByFidWithResponse call
func ParseGetStorageLimitsByFidResp(rsp *http.Response) (*GetStorageLimitsByFidResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStorageLimitsByFidResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageLimitsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSubmitMessageResp parses an HTTP response from a SubmitMessageWithResponse call
func ParseSubmitMessageResp(rsp *http.Response) (*SubmitMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserDataByFidResp parses an HTTP response from a GetUserDataByFidWithResponse call
func ParseGetUserDataByFidResp(rsp *http.Response) (*GetUserDataByFidResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserDataByFidResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsernameProofResp parses an HTTP response from a GetUsernameProofWithResponse call
func ParseGetUsernameProofResp(rsp *http.Response) (*GetUsernameProofResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsernameProofResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserNameProof
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUsernameProofsByFidResp parses an HTTP response from a ListUsernameProofsByFidWithResponse call
func ParseListUsernameProofsByFidResp(rsp *http.Response) (*ListUsernameProofsByFidResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsernameProofsByFidResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsernameProofsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseValidateMessageResp parses an HTTP response from a ValidateMessageWithResponse call
func ParseValidateMessageResp(rsp *http.Response) (*ValidateMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidateMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListVerificationsByFidResp parses an HTTP response from a ListVerificationsByFidWithResponse call
func ParseListVerificationsByFidResp(rsp *http.Response) (*ListVerificationsByFidResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVerificationsByFidResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages      []Verification `json:"messages"`
			NextPageToken []byte         `json:"nextPageToken"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
